/*
 * Copyright 2018 National Technology & Engineering Solutions of
 * Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,
 * the U.S. Government retains certain rights in this software.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Sandia Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <iostream>#include <fstream>#include <string>#include <stdlib.h>#include <math.h>       /* cbrt */#include <vector>using namespace std;void test_fixed_procs_per_node(int num_server_procs_per_node_serrano_ghost, int num_server_procs_per_node_skybridge_chama,							   int num_client_procs_per_node_serrano_ghost, int num_client_procs_per_node_skybridge_chama);void test_num_server_procs_per_node();void test_num_client_procs_per_node(int num_server_procs_per_node);void generate_txn_file(string cluster, int job_num, int iteration, string testing_type, int time, int num_datasets, int num_types,						int total_nodes, int server_nodes, int client_nodes, int num_server_procs, int client_procs, 						int server_procs_per_node, int client_procs_per_node, int num_x_procs,						int num_y_procs, int num_z_procs);int main(int argc, char **argv) {	// test_num_client_procs_per_node(16);	// generate_txn_file("serrano", 0, 0, "fixed_proc_per_node_testing", 180, 10, 10, 10, 1, 8, 4, 120, 4, 15, 4, 5, 6);	// cout << "About to generate combos \n";	int num_server_procs_per_node_serrano_ghost = 16;	int num_server_procs_per_node_skybridge_chama = 16;	int num_client_procs_per_node_serrano_ghost = 32;	int num_client_procs_per_node_skybridge_chama = 16;	test_fixed_procs_per_node(num_server_procs_per_node_serrano_ghost, num_server_procs_per_node_skybridge_chama,							  num_client_procs_per_node_serrano_ghost, num_client_procs_per_node_skybridge_chama);							    // add return value/tests to make sure things went okay?	// test_num_server_procs_per_node();}void generate_txn_file(string cluster, int job_num, int iteration, string testing_type, int time, int num_datasets, int num_types,						int total_nodes, int num_server_nodes, int num_client_nodes, int num_server_procs, int client_procs, 						int server_procs_per_node, int client_procs_per_node, int num_x_procs,						int num_y_procs, int num_z_procs) {		// cout << " server procs: " << num_server_procs << " num types: " << num_types << " num datasets: " << num_datasets << " npx: " << 				// num_x_procs << " npy: " << num_y_procs << " npz: " << num_z_procs << endl;		int estm_num_time_pts_client = num_server_procs * num_types * num_datasets * num_x_procs * num_y_procs * num_z_procs;		int estm_num_time_pts_server = .5 * estm_num_time_pts_client;		// cout << "estm time pts client: " << estm_num_time_pts_client << endl;		// cout << "estm time pts server: " << estm_num_time_pts_server << endl;		int x_length_per_proc = 200;		int y_length_per_proc = 200;		int z_length_per_proc = 200;		int nx = x_length_per_proc * num_x_procs;		int ny = y_length_per_proc * num_y_procs;		int nz = z_length_per_proc * num_z_procs;		char client_cmd_line_args[256];					// #Dirman hexid,     npx,npy,npz,nx,ny,nz,num datasets,num types 		snprintf(client_cmd_line_args, sizeof(client_cmd_line_args), "%s %d %d %d %d %d %d %d %d %d %d", 				"${MD_DIRMAN_CONTACT_INFO}", num_x_procs, num_y_procs, num_z_procs, 				nx, ny, nz, num_datasets, num_types, estm_num_time_pts_client, num_server_procs);		string account = "fy140262";		string testing_file_name = "testing_harness"; 		string sbatch_path = "/gscratch/mlawso/runtime_" + cluster + "/job_scripts/" +  testing_type;		string job_name = "txn."+testing_type + "_" + cluster + "_" + to_string(job_num); 		string testing_params;		if( !testing_type.compare("server_proc_per_node_testing") ) {	 		testing_params = to_string(server_procs_per_node) + "_" + to_string(iteration);		}		else if( !testing_type.compare("client_proc_per_node_testing") ) {	 		testing_params = to_string(client_procs_per_node) + "_" + to_string(iteration);		}		else if( !testing_type.compare("fixed_proc_per_node_testing") ) {	 		testing_params = to_string(num_server_procs) + "_" + to_string(num_server_nodes) +	 						 "_" + to_string(client_procs) + "_" + to_string(num_client_nodes) +	 						 "_" + to_string(num_datasets) + "_" + to_string(num_types) + "_" + to_string(iteration);		}		string sbatch_file_name = testing_params + ".sl";		string sbatch_file_path = sbatch_path + "/" + sbatch_file_name;		// cout << " sbatch_file_path: " << sbatch_file_path << endl;		string results_file_name = testing_params + ".log";		string sbatch_script_path= sbatch_path + "/"  + "sbatch_script";		// cout << " results file path: " << sbatch_file_path << endl;		int hrs = time / 3600; //is there a max time ?, make sure formula makes sense		int mins = (time - 3600*hrs) / 60;		int secs = time - 3600 * hrs - 60*mins; 		char time_str[30];		sprintf(time_str, "#SBATCH --time=%.2d:%.2d:%.2d", hrs, mins, secs);		ofstream file;		file.open(sbatch_file_path);		file << "#!/bin/bash" << endl << endl;		file << "#SBATCH --account=" << account << endl;		// file << "#SBATCH --partition=" << partition << endl;		file << "#SBATCH --job-name=" << job_name << endl;		file << "#SBATCH --nodes=" << total_nodes << endl;		file << time_str << endl;		file << endl;		// file << "echo starting txn testing" << endl;		file << endl;		if( !cluster.compare("skybridge") ) {			file << "SOURCE_DIR=/gscratch/mlawso/runtime_skybridge/source" << endl;			file << "OUTPUT_DIR=/gscratch/mlawso/runtime_skybridge/output/" << testing_type << endl;			}		else if( !cluster.compare("serrano") ) {			file << "SOURCE_DIR=/gscratch/mlawso/runtime_serrano/source" << endl;			file << "OUTPUT_DIR=/gscratch/mlawso/runtime_serrano/output/" << testing_type << endl;			}		else if( !cluster.compare("chama") ) {			file << "SOURCE_DIR=/gscratch/mlawso/runtime_chama/source" << endl;			file << "OUTPUT_DIR=/gscratch/mlawso/runtime_chama/output/" << testing_type << endl;			}		else if( !cluster.compare("ghost") ) {			file << "SOURCE_DIR=/gscratch/mlawso/runtime_ghost/source" << endl;			file << "OUTPUT_DIR=/gscratch/mlawso/runtime_ghost/output/" << testing_type << endl;			}		else {			cout << "Error. Given cluster did not match skybridge, serrano, chama or ghost \n";			return;		}		file << "NUM_SERVERS=" << num_server_procs << endl;		file << "NUM_CLIENTS=" << client_procs <<endl;		file << "NUM_SERVERS_PER_NODE=" << server_procs_per_node << endl;		file << "NUM_CLIENTS_PER_NODE=" << client_procs_per_node << endl;		file << endl;		file << "cd $SOURCE_DIR" << endl;		file << endl;		file << "DIRMAN_FILE_NAME=my_dirman" << endl;		file << "SERVER_FILE_NAME=my_metadata_server" << endl;		file << "TESTING_FILE_NAME=" << testing_file_name << endl; 		file << endl;		file << "export MD_DIRMAN_CONTACT_INFO=${SOURCE_DIR}/md_dirman_contact_info_" << job_num << ".txt" << endl;		file << endl;		file << "DIRMAN_LOG_FILE=${OUTPUT_DIR}/${DIRMAN_FILE_NAME}"<< "_" << 				results_file_name << endl;		file << "SERVER_LOG_FILE=${OUTPUT_DIR}/${SERVER_FILE_NAME}"<<  "_" << 				results_file_name << endl;		file << "TESTING_LOG_FILE=${OUTPUT_DIR}/${TESTING_FILE_NAME}"<<  "_" << 				results_file_name << endl;		file << endl;		file << "DIRMANNODE=`scontrol show hostname $SLURM_HOSTNAME | head -n 1`" << endl;		file << "SERVERNODES=`scontrol show hostname $SLURM_HOSTNAME | head -n " << 1+num_server_nodes << " | tail -n " << num_server_nodes << " | awk -vORS=, '{ print $1 }' | sed 's/,$//'`" << endl;		file << "CLIENTNODES=`scontrol show hostname $SLURM_HOSTNAME | tail -n " << num_client_nodes << " | awk -vORS=, '{ print $1 }' | sed 's/,$//'`" << endl;		file << endl;		file << "mpiexec --host $DIRMANNODE -np 1 --npernode 1 ${SOURCE_DIR}/${DIRMAN_FILE_NAME} &> ${DIRMAN_LOG_FILE} & " << endl;		file << endl;		// file << "sleep 15" << endl;		// file << endl;		file << "mpiexec --host $SERVERNODES -np ${NUM_SERVERS} --npernode ${NUM_SERVERS_PER_NODE} ${SOURCE_DIR}/${SERVER_FILE_NAME} " <<				"${MD_DIRMAN_CONTACT_INFO} " << estm_num_time_pts_server << " &> ${SERVER_LOG_FILE} &" << endl;		file << endl;		// file << "sleep 15" << endl;		// file << endl;		file << "mpiexec --host $CLIENTNODES -np ${NUM_CLIENTS} --npernode ${NUM_CLIENTS_PER_NODE} ${SOURCE_DIR}/${TESTING_FILE_NAME} " <<				client_cmd_line_args << " &> ${TESTING_LOG_FILE} " << endl;		file << endl;		file.close();		ofstream sbatch_script;		if(job_num == 0) {			sbatch_script.open(sbatch_script_path);				sbatch_script << "#! /bin/bash \n\n";			sbatch_script << "jid0=$(sbatch " + sbatch_file_name + " | awk '{print $4}')\n"; 		}		else {			sbatch_script.open(sbatch_script_path, std::ofstream::app);							sbatch_script << "jid" + to_string(job_num) + "=$(sbatch --dependency=afterany:$jid" +to_string(job_num-1) + " " + sbatch_file_name + " | awk '{print $4}')\n"; 		}		sbatch_script.close();	}void test_fixed_procs_per_node(int num_server_procs_per_node_serrano_ghost, int num_server_procs_per_node_skybridge_chama,							   int num_client_procs_per_node_serrano_ghost, int num_client_procs_per_node_skybridge_chama) {	int num_server_procs[] = {16, 32, 64, 128, 256, 512};	int num_client_procs[] = {1024, 2048, 4096, 8192, 16384};	// int num_datasets[] = {96, 288, 2880, 17280};	int num_datasets[] = {2};	int num_types[] = {0, 10};	int num_server_procs_opts = sizeof(num_server_procs) / sizeof(int);	int num_client_procs_opts = sizeof(num_client_procs) / sizeof(int);	int num_datasets_opts = sizeof(num_datasets_opts) / sizeof(int);	int num_types_opts = sizeof(num_types) / sizeof(int);	int num_x_procs[num_client_procs_opts];	int num_y_procs[num_client_procs_opts];	int num_z_procs[num_client_procs_opts];	// std::cout << num_server_procs_opts << std::endl;	// std::cout << num_client_procs_opts << std::endl;	// std::cout << num_datasets_opts << std::endl;	// std::cout << num_types_opts << std::endl;	for(int i=0; i<5; i++) {		int num_procs = num_client_procs[i];		int my_cbrt = cbrt(num_procs);		while(num_procs % my_cbrt != 0) {			my_cbrt -= 1;		}		int my_cbrt2 = cbrt(num_procs);		while(num_procs % my_cbrt2 != 0) {			my_cbrt2 += 1;		}		num_x_procs[i] = my_cbrt;		num_y_procs[i] = my_cbrt2;		num_z_procs[i] = num_procs / (my_cbrt * my_cbrt2);		if(num_z_procs < num_y_procs) {			int temp = num_y_procs[i];			num_y_procs[i] = num_z_procs[i];			num_z_procs[i] = temp;		}    	    	// cout << "total num procs per var: " << num_procs << endl;    	// cout << "num x procs: " << num_x_procs << " num y procs: " << num_y_procs <<    	//      " num z procs: " << num_z_procs << endl;    	// cout << "confirming: total num of procs per var is calculated to be: " <<     	// 		num_x_procs * num_y_procs  * num_z_procs << endl;	}	float max_perc_of_cluster = .5;	int max_num_nodes_skybridge = 1848 * max_perc_of_cluster;	int max_num_processes_per_node_skybridge = 16;	int max_num_nodes_serrano = 1122 * max_perc_of_cluster;	int max_num_processes_per_node_serrano = 36;	int max_num_nodes_ghost = 740 * max_perc_of_cluster;	int max_num_processes_per_node_ghost = 36;	int max_num_nodes_chama = 1232 * max_perc_of_cluster;	int max_num_processes_per_node_chama = 16;	string cluster;	string testing_type = "fixed_proc_per_node_testing";	int time;	// int size_of_array = sizeof(int) * num_server_procs_opts * num_server_procs_per_node_opts *	// 				   num_client_procs_opts * num_client_procs_per_node_opts * num_generate_opts_per_combo;	// int *combos_vals = (int *)malloc(size_of_array);	// cout << "size of array: " << sizeof(int) * num_server_procs_opts * num_server_procs_per_node_opts *	// 				   num_client_procs_opts * num_client_procs_per_node_opts * 6 << endl;	//note: current number of opts = 6*5*4*2*2 (num of clusters) = 480 (not accounting for numer eliminated for having too many procs/nodes requested)	int job_num_skybridge=0;	int job_num_serrano=0;	int job_num_ghost=0;	int job_num_chama=0;	for (int j=0; j<num_client_procs_opts; j++) {		for (int i=0; i< num_server_procs_opts; i++) {			for (int k=0; k<num_datasets_opts; k++) {				for (int l=0; l<num_types_opts; l++) {					// std::cout << num_server_procs[i] / num_server_procs_per_node[j] << std::endl;					// std::cout << num_client_procs[k] / num_client_procs_per_node[l] << std::endl;					int my_num_server_procs = num_server_procs[i];					int my_num_client_procs = num_client_procs[j];					if( (my_num_client_procs / my_num_server_procs) < 32) {						continue;					}					int num_server_nodes_serrano_ghost =  my_num_server_procs / num_server_procs_per_node_serrano_ghost;					int num_server_nodes_skybridge_chama =  my_num_server_procs / num_server_procs_per_node_skybridge_chama;					int num_client_nodes_serrano_ghost = my_num_client_procs / num_client_procs_per_node_serrano_ghost;					int num_client_nodes_skybridge_chama = my_num_client_procs / num_client_procs_per_node_skybridge_chama;					int total_nodes_serrano_ghost = num_server_nodes_serrano_ghost + num_client_nodes_serrano_ghost + 1; //dirman node					int total_nodes_skybridge_chama = num_server_nodes_skybridge_chama + num_client_nodes_skybridge_chama + 1; //dirman node					int my_num_datasets = num_datasets[k];					int my_num_types = num_types[l];					time = 600; 					if (total_nodes_skybridge_chama <= max_num_nodes_skybridge &&						num_server_procs_per_node_skybridge_chama <= max_num_processes_per_node_skybridge &&						num_client_procs_per_node_skybridge_chama <= max_num_processes_per_node_skybridge) {											cluster = "skybridge";						for(int iteration=0; iteration<5; iteration++) {							generate_txn_file(cluster, job_num_skybridge, iteration, testing_type, time, my_num_datasets, my_num_types,							total_nodes_skybridge_chama, num_server_nodes_skybridge_chama, num_client_nodes_skybridge_chama, my_num_server_procs, my_num_client_procs, 							num_server_procs_per_node_skybridge_chama, num_client_procs_per_node_skybridge_chama, num_x_procs[j], num_y_procs[j], num_z_procs[j]);							job_num_skybridge++;						}					}					if (total_nodes_serrano_ghost <= max_num_nodes_serrano &&						num_server_procs_per_node_serrano_ghost <= max_num_processes_per_node_serrano &&						num_client_procs_per_node_serrano_ghost <= max_num_processes_per_node_serrano) {													cluster = "serrano";						for(int iteration=0; iteration<5; iteration++) {							generate_txn_file(cluster, job_num_serrano, iteration, testing_type, time, my_num_datasets, my_num_types,							total_nodes_serrano_ghost, num_server_nodes_serrano_ghost, num_client_nodes_serrano_ghost, my_num_server_procs, my_num_client_procs, 							num_server_procs_per_node_serrano_ghost, num_client_procs_per_node_serrano_ghost, num_x_procs[j], num_y_procs[j], num_z_procs[j]);							job_num_serrano++;						}					}					if (total_nodes_serrano_ghost <= max_num_nodes_ghost &&						num_server_procs_per_node_serrano_ghost <= max_num_processes_per_node_ghost &&						num_client_procs_per_node_serrano_ghost <= max_num_processes_per_node_ghost) {													cluster = "ghost";						for(int iteration=0; iteration<5; iteration++) {							generate_txn_file(cluster, job_num_ghost, iteration, testing_type, time, my_num_datasets, my_num_types,							total_nodes_serrano_ghost, num_server_nodes_serrano_ghost, num_client_nodes_serrano_ghost, my_num_server_procs, my_num_client_procs, 							num_server_procs_per_node_serrano_ghost, num_client_procs_per_node_serrano_ghost, num_x_procs[j], num_y_procs[j], num_z_procs[j]);							job_num_ghost++;						}					}					if (total_nodes_skybridge_chama <= max_num_nodes_chama &&						num_server_procs_per_node_skybridge_chama <= max_num_processes_per_node_chama &&						num_client_procs_per_node_skybridge_chama <= max_num_processes_per_node_chama) {													cluster = "chama";						for(int iteration=0; iteration<5; iteration++) {							generate_txn_file(cluster, job_num_chama, iteration, testing_type, time, my_num_datasets, my_num_types,							total_nodes_skybridge_chama, num_server_nodes_skybridge_chama, num_client_nodes_skybridge_chama, my_num_server_procs, my_num_client_procs, 							num_server_procs_per_node_skybridge_chama, num_client_procs_per_node_skybridge_chama, num_x_procs[j], num_y_procs[j], num_z_procs[j]);							job_num_chama++;						}					}				}				}		}	}}void test_num_server_procs_per_node() { // IF WE ARE GOING TO VARY ALL VARIABLES, CAN JUST MODIFY GENERATE COMBOS TO TAKE VARS FOR num prcs and num procs per node	int num_server_procs = 32;	// int num_server_procs_per_node[] = {1, 2, 4, 8, 16, 32}; 	int num_server_procs_per_node[] = {32, 16, 8, 4, 2, 1}; 	int num_client_procs = 1024;	int num_client_procs_per_node = 16;	// int num_datasets = 288;	int num_datasets = 2;	int num_types = 10;	int num_server_procs_per_node_opts = sizeof(num_server_procs_per_node) / sizeof(int);	// std::cout << num_server_procs_per_node_opts << std::endl;	int size_of_array = sizeof(int) * num_server_procs_per_node_opts;	int num_procs = num_client_procs;	int my_cbrt = cbrt(num_procs);	while(num_procs % my_cbrt != 0) {		my_cbrt -= 1;	}	int my_cbrt2 = cbrt(num_procs);	while(num_procs % my_cbrt2 != 0) {		my_cbrt2 += 1;	}	int num_x_procs = my_cbrt;	int num_y_procs = my_cbrt2;	int num_z_procs = num_procs / (my_cbrt * my_cbrt2);	if(num_z_procs < num_y_procs) {		int temp = num_y_procs;		num_y_procs = num_z_procs;		num_z_procs = temp;	}    	    	// cout << "total num procs per var: " << num_procs << endl;    	// cout << "num x procs: " << num_x_procs << " num y procs: " << num_y_procs <<    	//      " num z procs: " << num_z_procs << endl;    	// cout << "confirming: total num of procs per var is calculated to be: " <<     	// 		num_x_procs * num_y_procs  * num_z_procs << endl;	float max_perc_of_cluster = .5;	int max_num_nodes_skybridge = 1848 * max_perc_of_cluster;	int max_num_processes_per_node_skybridge = 16;	int max_num_nodes_serrano = 1122 * max_perc_of_cluster;	int max_num_processes_per_node_serrano = 36;	int max_num_nodes_ghost = 740 * max_perc_of_cluster;	int max_num_processes_per_node_ghost = 36;	int max_num_nodes_chama = 1232 * max_perc_of_cluster;	int max_num_processes_per_node_chama = 16;	int time;	string cluster;	string testing_type = "server_proc_per_node_testing";	int job_num_skybridge=0;	int job_num_serrano=0;	int job_num_ghost=0;	int job_num_chama=0;	for (int i=0; i< num_server_procs_per_node_opts; i++) {					// std::cout << num_server_procs[i] / num_server_procs_per_node[j] << std::endl;					// std::cout << num_client_procs[k] / num_client_procs_per_node[l] << std::endl;		int num_server_nodes = num_server_procs / num_server_procs_per_node[i];		int num_client_nodes = num_client_procs / num_client_procs_per_node;		int total_nodes = num_server_nodes + num_client_nodes + 1; //dirman node		time = 100; 		if (total_nodes <= max_num_nodes_skybridge &&			num_server_procs_per_node[i] <= max_num_processes_per_node_skybridge) {			cluster = "skybridge";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_skybridge, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node[i], 				num_client_procs_per_node, num_x_procs, num_y_procs, num_z_procs);				job_num_skybridge++;			}		}		if (total_nodes <= max_num_nodes_serrano &&			num_server_procs_per_node[i] <= max_num_processes_per_node_serrano) {			cluster = "serrano";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_serrano, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node[i], 				num_client_procs_per_node, num_x_procs, num_y_procs, num_z_procs);				job_num_serrano++;			}		}		if (total_nodes <= max_num_nodes_ghost && 			num_server_procs_per_node[i] <= max_num_processes_per_node_ghost) {										cluster = "ghost";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_ghost, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node[i], 				num_client_procs_per_node, num_x_procs, num_y_procs, num_z_procs);				job_num_ghost++;			}		}		if (total_nodes <= max_num_nodes_chama &&			num_server_procs_per_node[i] <= max_num_processes_per_node_chama) {										cluster = "chama";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_chama, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node[i], 				num_client_procs_per_node, num_x_procs, num_y_procs, num_z_procs);				job_num_chama++;			}		}	}}void test_num_client_procs_per_node(int num_server_procs_per_node) {	int num_server_procs = 32;	int num_client_procs = 1024;	// int num_client_procs_per_node[] = {1, 2, 4, 8, 16, 32};	int num_client_procs_per_node[] = {32, 16, 8, 4, 2, 1};	// int num_datasets = 288;	int num_datasets = 2;	int num_types = 10;	int num_client_procs_per_node_opts = sizeof(num_client_procs_per_node) / sizeof(int);	// std::cout << num_server_procs_per_node_opts << std::endl;	int size_of_array = sizeof(int) * num_client_procs_per_node_opts;	int num_procs = num_client_procs;	int my_cbrt = cbrt(num_procs);	while(num_procs % my_cbrt != 0) {		my_cbrt -= 1;	}	int my_cbrt2 = cbrt(num_procs);	while(num_procs % my_cbrt2 != 0) {		my_cbrt2 += 1;	}	int num_x_procs = my_cbrt;	int num_y_procs = my_cbrt2;	int num_z_procs = num_procs / (my_cbrt * my_cbrt2);	if(num_z_procs < num_y_procs) {		int temp = num_y_procs;		num_y_procs = num_z_procs;		num_z_procs = temp;	}	float max_perc_of_cluster = .5;	int max_num_nodes_skybridge = 1848 * max_perc_of_cluster;	int max_num_processes_per_node_skybridge = 16;	int max_num_nodes_serrano = 1122 * max_perc_of_cluster;	int max_num_processes_per_node_serrano = 36;	int max_num_nodes_ghost = 740 * max_perc_of_cluster;	int max_num_processes_per_node_ghost = 36;	int max_num_nodes_chama = 1232 * max_perc_of_cluster;	int max_num_processes_per_node_chama = 16;	int time;	string cluster;	string testing_type = "client_proc_per_node_testing";	int job_num_skybridge=0;	int job_num_serrano=0;	int job_num_ghost=0;	int job_num_chama=0;	for (int i=0; i< num_client_procs_per_node_opts; i++) {					// std::cout << num_server_procs[i] / num_server_procs_per_node[j] << std::endl;					// std::cout << num_client_procs[k] / num_client_procs_per_node[l] << std::endl;		int num_server_nodes = num_server_procs / num_server_procs_per_node;		int num_client_nodes = num_client_procs / num_client_procs_per_node[i];		int total_nodes = num_server_nodes + num_client_nodes + 1; //dirman node		time = 100; 		if (total_nodes <= max_num_nodes_skybridge &&			num_client_procs_per_node[i] <= max_num_processes_per_node_skybridge) {			cluster = "skybridge";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_skybridge, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node, 				num_client_procs_per_node[i], num_x_procs, num_y_procs, num_z_procs);				job_num_skybridge++;			}		}		if (total_nodes <= max_num_nodes_serrano &&			num_client_procs_per_node[i] <= max_num_processes_per_node_serrano) {			cluster = "serrano";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_serrano, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node, 				num_client_procs_per_node[i], num_x_procs, num_y_procs, num_z_procs);				job_num_serrano++;			}		}		if (total_nodes <= max_num_nodes_ghost &&			num_client_procs_per_node[i] <= max_num_processes_per_node_ghost) {			cluster = "ghost";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_ghost, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node, 				num_client_procs_per_node[i], num_x_procs, num_y_procs, num_z_procs);				job_num_ghost++;			}		}		if (total_nodes <= max_num_nodes_chama &&			num_client_procs_per_node[i] <= max_num_processes_per_node_chama) {			cluster = "chama";			for(int iteration=0; iteration<5; iteration++) {				generate_txn_file(cluster, job_num_chama, iteration, testing_type, time, num_datasets, num_types,				total_nodes, num_server_nodes, num_client_nodes, num_server_procs, num_client_procs, num_server_procs_per_node, 				num_client_procs_per_node[i], num_x_procs, num_y_procs, num_z_procs);				job_num_chama++;			}		}	}} 